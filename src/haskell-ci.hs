#!/usr/bin/env stack
-- stack --resolver lts-10.8 script --package foundation --package basement --package memory --package directory --package cryptonite
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE BangPatterns #-}

import           Data.Char
import           Data.List hiding (head)
import           Data.Either
import           Basement.NormalForm
import           Data.Function (on)
import           Control.Monad (when)
import           System.Directory
import           System.Environment
import           System.Exit
import           System.IO
import           Crypto.Hash (hashWith, SHA256(..), Digest)
import           Config
import           Build
import           Resolver
import           Utils
import           Travis
import           Appveyor
import           Stack
import qualified Yaml as Y
import qualified Foundation    as F
import qualified Foundation    as F
import           Foundation.Collection (nonEmpty, head, getNonEmpty)
import           Prelude hiding (head)

hci = ".haskell-ci"

-- read and parse .haskell-ci
readHci = do
    y <- doesFileExist hci
    when (not y) $ quitWith "no .haskell-ci file found"
    parse . force <$> readFile hci

cmdAppveyor = do
    cfg <- readHci
    h   <- readHciHash
    putStrLn $ toAppveyor h cfg
    return ()

cmdTravis = do
    cfg <- readHci
    h   <- readHciHash
    putStrLn $ toTravis h cfg
    return ()

main = do

    a <- getArgs
    case a of
        ["generate"] -> do
            already <- doesFileExist hci
            when already $ quitWith ("this directory already contains a " ++ hci ++ " file")
            writeFile hci $ unlines
                [ "# compiler supported and their equivalent LTS"
                , "compiler: ghc-7.8 lts-2.22"
                , "compiler: ghc-7.10 lts-6.35"
                , "compiler: ghc-8.0 lts-9.21"
                , "compiler: ghc-8.2 lts-10.7"
                , "#compiler: ghc-8.4 ghc-8.4-rc1"
                , ""
                , "# gitdep: name location commit"
                , ""
                , "# options"
                , "# option: alias x=y z=v"
                , ""
                , "# builds"
                , "# recognized simple options: nohaddock allow-newer allowed-failure"
                , "# kvs options: flag=pkg:flagname extradep=package-version gitdep=name"
                , "build: ghc-7.8 nohaddock"
                , "build: ghc-8.2"
                , "build: ghc-7.10"
                , "build: ghc-8.0"
                , "build: ghc-8.0 os=osx"
                , "#build: ghc-8.4 tests=no benchs=no allow-newer"
                , ""
                , "# packages"
                , "package: '.'"
                , ""
                , "# extra builds"
                , "hlint: allowed-failure"
                , "weeder: allowed-failure"
                , "coverall: false"
                , ""
                , "# travis extra"
                , "# travis-apt-addon: packagename"
                , "# travis-tests: post-script"
                ]
        ["appveyor"]    -> cmdAppveyor
        ["travis"]      -> cmdTravis
        ("stack":name:[]) -> do
            cfg <- readHci
            h   <- readHciHash
            case find (\(BuildEnv b _ _) -> b == name) (builds cfg) of
                Nothing   -> quitWith ("no build name called " ++ name ++ " found")
                Just benv -> do
                    let resolved = resolveBuild cfg benv
                        build    = makeBuildFromEnv cfg resolved
                        gen      = stackYaml build
                    putStrLn $ unlines [ yamlAutoGeneratedComment h, gen ]
        ("update":[]) -> do
            !cfg <- readHci
            !h   <- readHciHash

            !hasTravis <- doesFileExist ".travis.yml"
            when hasTravis $ do
                travisFirstLine <- fmap head . nonEmpty . lines <$> readFile ".travis.yml"
                case yamlGetAutogeneratedHash =<< travisFirstLine of
                    Nothing        -> putStrLn "travis is not autogenerated"
                    Just foundHash -> do
                        if foundHash == h
                            then putStrLn "* skipping travis. already uptodate"
                            else do
                                putStrLn "updating travis, saving previous one to .travis.yml.sav"
                                renameFile ".travis.yml" ".travis.yml.sav" 
                                writeFile ".travis.yml" $ toTravis h cfg
        ("test-all":[]) -> do
            cfg <- readHci
            h   <- readHciHash
            putStrLn "not implemented"
        -- ["local-build"] -> do -- try to run all builds locally with every resolver capable on this system
        --    cfg <- readHci
        --    let builds = map (resolveBuilds cfg) $ builds cfg
        _            -> do
            hPutStrLn stderr "usage: haskell-ci [generate|travis|stack <name>|update]"
            exitFailure
